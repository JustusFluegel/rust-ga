// I wrote these tests because the following program came out as
// a solution to th Median problem (return the median of three
// inputs), when wasn't correct.
//
// [Int-Multiply c a c Bool-Not Int-GreaterThanEqual b Bool-Dup Exec-Swap
// Int-Max Exec-When { Bool-Push(false) Int-Min Int-Max]
//
// I figured I'd capture this in tests while I was debugging the problem.
//
// It turned out that the problem was that all the comparison operators on
// integers only removed _one_ value from the int stack instead of 2. It
// turns out that evolution cleverly figured out how to use that to its
// advantage to solve the problem.

#![cfg(test)]

use push::{
    arr_into,
    genome::plushy::Plushy,
    instruction::{
        BoolInstruction, ExecInstruction, IntInstruction, PushInstruction::InputVar,
        variable_name::VariableName,
    },
    push_vm::{HasStack, State, program::PushProgram, push_state::PushState},
};
use test_case::test_case;

#[test_case(5, 10, 15; "b is the median, a<b<c")]
#[test_case(5, 15, 10; "c is the median, a<c<b")]
#[test_case(10, 5, 15; "a is the median, b<a<c")]
#[test_case(10, 15, 5; "a is the median, c<a<b")]
#[test_case(15, 5, 10; "c is the median, b<c<a")]
#[test_case(15, 10, 5; "b is the median, c<b<a")]
fn repaired_median(a: i64, b: i64, c: i64) {
    let expected = (a.min(b)).max((a.max(b)).min(c));
    let program = build_working_median();
    let state = PushState::builder()
        .with_max_stack_size(1_000)
        .with_instruction_step_limit(1_000)
        .with_program(program)
        .unwrap()
        .with_int_input("a", a)
        .with_int_input("b", b)
        .with_int_input("c", c)
        .build();

    let final_state = state.run_to_completion().unwrap();
    let result = final_state.stack::<i64>().top().unwrap();
    assert_eq!(result, &expected);
}

// A repaired version of the initial (incorrect) evolved implementation of
// Median:
//
//    [Int-Multiply c a Int-Dup c Bool-Not Int-GreaterThanEqual b
//     Bool-Dup Exec-Swap Int-Max Exec-When { Bool-Push(false) Int-Min Int-Max]
//
// Since this worked when `Int-GreaterThanEqual` failed to remove both values
// from the int stack, it should work if I add an instruction that duplicates
// the first argument before calling the comparison. So I inserted an
// `Int-Dup` as a new fourth instructions.
fn build_working_median() -> Vec<PushProgram> {
    // Create an instance of our target program
    let a = InputVar(VariableName::new("a"));
    let b = InputVar(VariableName::new("b"));
    let c = InputVar(VariableName::new("c"));
    let genes = arr_into![
        IntInstruction::multiply(),
        c.clone(),
        a,
        IntInstruction::dup(), // This is the crucial addition that fixes the program.
        c,
        BoolInstruction::not(),
        IntInstruction::greater_than_equal(),
        b,
        BoolInstruction::dup(),
        ExecInstruction::swap(),
        IntInstruction::max(),
        ExecInstruction::when(),
        IntInstruction::min(),
        IntInstruction::max(),
    ];

    let plushy: Plushy = genes.into_iter().collect();
    let program: Vec<PushProgram> = plushy.into();
    program
}

#[test_case(5, 10, 15; "b is the median, a<b<c")]
#[test_case(5, 15, 10; "c is the median, a<c<b")]
#[test_case(10, 5, 15; "a is the median, b<a<c")]
#[test_case(10, 15, 5; "a is the median, c<a<b")]
#[test_case(15, 5, 10; "c is the median, b<c<a")]
#[test_case(15, 10, 5; "b is the median, c<b<a")]
fn median(a: i64, b: i64, c: i64) {
    let expected = (a.min(b)).max((a.max(b)).min(c));
    let program = re_evolved_median();
    let state = PushState::builder()
        .with_max_stack_size(1_000)
        .with_instruction_step_limit(1_000)
        .with_program(program)
        .unwrap()
        .with_int_input("a", a)
        .with_int_input("b", b)
        .with_int_input("c", c)
        .build();

    let final_state = state.run_to_completion().unwrap();
    let result = final_state.stack::<i64>().top().unwrap();
    assert_eq!(result, &expected);
}

// A working implementation of Median:
//    [b a Int-Max c b Int-StackDepth Int-Inc Int-StackDepth Int-Power
//     Int-IsNegative a Exec-DupBlock { Int-Min Int-Max]
// This was generated by doing another evolutionary run after
// fixing the comparison instructions.
fn re_evolved_median() -> Vec<PushProgram> {
    // Create an instance of our target program
    let a = InputVar(VariableName::new("a"));
    let b = InputVar(VariableName::new("b"));
    let c = InputVar(VariableName::new("c"));
    let genes = arr_into![
        b.clone(),
        a.clone(),
        IntInstruction::max(),
        c,
        b,
        IntInstruction::stack_depth(),
        IntInstruction::inc(),
        IntInstruction::stack_depth(),
        IntInstruction::power(),
        IntInstruction::is_negative(),
        a,
        ExecInstruction::dup_block(),
        IntInstruction::min(),
        IntInstruction::max(),
    ];

    let plushy: Plushy = genes.into_iter().collect();
    let program: Vec<PushProgram> = plushy.into();
    program
}
